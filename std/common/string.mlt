type String {}

vocab mlatu {
  intrinsic string_from_list (List[Char] -> String)
  intrinsic string_to_list (String -> List[Char])
  intrinsic string_concat (String, String -> String)
      intrinsic gt_string (String, String -> Bool)
    intrinsic eq_string (String, String -> Bool)
}

instance > (String, String -> Bool) { _::mlatu::gt_string }
instance < (String, String -> Bool) { swap (>) }
instance <= (String, String -> Bool) { (>) not }
instance >= (String, String -> Bool) { (<) not }
instance = (String, String -> Bool) { _::mlatu::eq_string}
instance <> (String, String -> Bool) { (=) not }

instance + (String, String -> String):
  _::mlatu::string_concat

define chars (String -> List[Char]) {
  _::mlatu::string_to_list
}

define from_chars (List[Char] -> String) {
  _::mlatu::string_from_list
}

trait show[T] (T -> String)

instance show (String -> String) {}

instance show (Char -> String):
  once from_chars

instance show (Bool -> String):
  if { "true" } else { "false" }

instance show[A, B] (Either[A, B] -> String):
  match 
  case left:
    show
  case right: 
    show

instance show[T] (Optional[T] -> String):
  match 
  case some -> x: 
    "some " + x show
  case none:
    "none"

vocab mlatu {

  intrinsic show_int64 (Int -> String)
  intrinsic show_float64 (Double -> String)

}

instance show (Int -> String):
  _::mlatu::show_int64

instance show (Double -> String):
  _::mlatu::show_float64

trait read[T] (String -> Optional[T])

instance read (String -> Optional[String]) { some }

instance read (String -> Optional[Char]):
  chars -> cs;
  if (cs length = 1):
    cs head
  else:
    none

instance read (String -> Optional[Bool]):
  -> s;
  if (s = "true"): true some
  else:
    if (s = "false"): false some
    else: none

vocab mlatu {
  intrinsic read_int64 (String -> Optional[Int])
  intrinsic read_float64 (String -> Optional[Double])

}

instance read (String -> Optional[Int]):
  _::mlatu::read_int64

instance read (String -> Optional[Double]):
  _::mlatu::read_float64

