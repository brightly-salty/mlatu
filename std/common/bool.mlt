trait & [T] (T, T -> T)

trait && [T] (T, (-> T) -> T)

trait --> [T] (T, T -> T)

trait not [T] (T -> T)

trait | [T] (T, T -> T)

trait || [T] (T, (-> T) -> T)

trait ~ [A] (A, A -> A)


type Bool:
  case false
  case true





instance & (Bool, Bool -> Bool):
  -> x, y;
  if (x):
    y
  else:
    false

instance & (Int, Int -> Int):
  _::mlatu::and_int64

instance && (Bool, (-> Bool) -> Bool):
  -> x, y;
  if (x):
    y call
  else:
    false

instance --> (Bool, Bool -> Bool):
  -> a, b;
  if (a):
    b
  else:
    true

instance --> (Int, Int -> Int):
  -> a, b;
  a not | b

instance not (Bool -> Bool):
  if:
    false
  else:
    true

instance not (Int -> Int):
  _::mlatu::not_int64

instance | (Bool, Bool -> Bool):
  -> x, y;
  if (x):
    true
  else:
    y

instance | (Int, Int -> Int):
  _::mlatu::or_int64

instance || (Bool, (-> Bool) -> Bool):
  -> x, y;
  if (x):
    true
  else:
    y call

instance ~ (Int, Int -> Int):
  _::mlatu::xor_int64

instance ~ (Bool, Bool -> Bool):
  swap if:
    not

define ---> (Bool, (-> Bool) -> Bool):
  -> a, b;
  if (a):
    b call
  else:
    true



define until [R...] (R..., (R... -> R..., Bool) -> R...):
  -> f;
  if (f call not):
    f until

define while [R...] (R..., (R... -> R..., Bool) -> R...):
  -> f;
  if (f call):
    f while

about ~:
  operator:
    5

about &:
  operator:
    right 3

about &&:
  operator:
    right 3

about |:
  operator:
    right 2

about ||:
  operator:
    right 2

about -->:
  operator:
    right 1

about --->:
  operator:
    right 1
