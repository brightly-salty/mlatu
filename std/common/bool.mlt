class And[T] { method & (T, T -> T) }

class LazyAnd[T] { method && (T, (-> T) -> T) }

class Implies[T] { method --> (T, T -> T) }

class Not[T] { method not (T -> T) }

class Or[T] { method | (T, T -> T) }

class LazyOr[T] { method || (T, (-> T) -> T) }

class Xor[A] { method ~ (A, A -> A) }


type Bool {   case false case true }

instance And for Int { define & (Int, Int -> Int) { _::mlatu::and_int64 } }

instance And for Bool { define & (Bool, Bool -> Bool) { swap (not) if { drop false } else {} } }

instance LazyAnd for Bool { define && (Bool, (-> Bool) -> Bool) { swap if { call } else { drop false } } }

instance Implies for Bool { define --> (Bool, Bool -> Bool) { swap (not) if { drop true } else {} } }

instance Implies for Bool { define --> (Int, Int -> Int) { swap not (|) } }

instance Not for Bool { define not (Bool -> Bool) { if { false } else { true } } }

instance Not for Int { define not (Int -> Int) { _::mlatu::not_int64 } }

instance Or for Int { define | (Int, Int -> Int) { _::mlatu::or_int64 } }

instance Or for Bool { define | (Bool, Bool -> Bool) { swap if { drop true } else {} } }

instance LazyOr for Bool { define || (Bool, (-> Bool) -> Bool) { swap if { drop true } else { call } } }

instance Xor for Int { define ~ (Int, Int -> Int) { _::mlatu::xor_int64 } }

instance Xor for Bool { define ~ (Bool, Bool -> Bool) { swap if { not } else {} } }

define ---> (Bool, (-> Bool) -> Bool) {
  swap (not)
  if { drop true }
  else { call }
}

define until [R...] (R..., (R... -> R..., Bool) -> R...) {
  -> f;
  if (f call not) { f until }
  else {}
}

define while [R...] (R..., (R... -> R..., Bool) -> R...) {
  -> f;
  if (f call) { f while }
  else {}
}

about ~ {
  operator {
    5
  }
}

about & {
  operator {
    right 3
  }
}

about && {
  operator {
    right 3
  }
}

about | {
  operator {
    right 2
  }
}

about || {
  operator {
    right 2
  }
}

about --> {
  operator {
    right 1
  }
}

about ---> {
  operator {
    right 1
  }
}
