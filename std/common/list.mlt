vocab mlatu {
  intrinsic cat (∀ t . t list, t list -> t list)
  intrinsic empty (∀ t . t list -> bool)
  intrinsic get (∀ t . t list, int -> t option)
  intrinsic hd (∀ t . t list -> t option)
  intrinsic init (∀ t . t list -> (t list) option)
  intrinsic last (∀ t . t list -> t option)
  intrinsic set (∀ t . t list, t, int -> (t list) option)
  intrinsic tl (∀ t . t list -> (t list) option)
}

type (t) list {}

define for-all (∀ t . t list, (t -> bool) -> bool) {
  -> f;
  true do (fold-left) { f call (&) }
}

define for-all2 (∀ a b . a list, b list, (a, b -> bool) -> bool) {
  -> f;
  combine { unpair f call } for-all
}

define and (bool list -> bool) { true \(&) fold-left }

define exists (∀ t . t list, (t -> bool) -> bool) {
  -> f;
  true do (fold-left) { f call (|) }
}

define exists2 (∀ a b . a list, b list, (a, b -> bool) -> bool) {
  -> f;
  combine { unpair f call } exists
}

define append (∀ t . t list, t list -> t list) { mlatu::cat }

define append3 (∀ t . t list, t list, t list -> t list) { append append }

define cartesian (∀ a b . a list, b list -> (b a pair) list) {
  \mk-pair cartesian-with
}

define cartesian-with (∀ a b c . a list, b list, (a, b -> c) -> c list) {
  -> ys, f;
  { -> x; ys { x swap f call } map } map-concat
}

define concat (∀ t . (t list) list -> t list) { [] \append fold-left }

define concat-options (∀ t . (t option) list -> t list) {
  [] do (fold-left) { match case some { suffix } else {} }
}

define each (∀ t . t list, (t ->) ->) {
  -> f;
  match (hd-tl)
  case some { unpair -> h, t; h f call t f each }
  case none {}
}

define each2 (∀ a b . a list, b list, (a, b ->) ->) {
  -> f;
  combine { unpair f call } each
}

define mem (∀ t . t, t list -> bool) { swap -> x; { x (=) } exists }

define empty (∀ t . t list -> bool) { mlatu::empty }

define filter (∀ t . t list, (t -> bool) -> t list) {
  -> f;
  match (tl-hd)
  case some { unpair -> t, h; t f filter (h f call) if { h cons } else {} }
  case none { [] }
}

define find (∀ t . t list, (t -> bool) -> t option) { filter hd }

define fold-left (∀ a b . b list, a, (a, b -> a) -> a) {
  -> xs, z, k;
  match (xs tl-hd)
  case some { unpair -> h; (z h k call) k fold-left }
  case none { z }
}

define fold-right (∀ a b . a list, b, (a, b -> b) -> b) {
  -> xs, z, k;
  match (xs init-last)
  case some { unpair z k call k fold-right }
  case none { z }
}

define get (∀ t . t list, int -> t option) { mlatu::get }

define get-all (∀ t . t list, int list -> (t option) list) {
  swap -> list;
  { list swap get } map
}

define glue (∀ t . t list, t list, t list -> t list) { prepend append }

define hd (∀ t . t list -> t option) { mlatu::hd }

define hd-tl (∀ t . t list -> ((t list) t pair) option) {
  \hd \tl bi \mk-pair lift-option-2
}

define init (∀ t . t list -> (t list) option) { mlatu::init }

define init-last (∀ t . t list -> (t (t list) pair) option) {
  \init \last bi \mk-pair lift-option-2
}

define insert-nth (∀ t . t list, t, int -> t list) {
  -> element, index;
  { if (index =) { -> x; [element, x] } else { -> x; [x] } } mapi concat
}

define join (∀ t . (t list) list, t list -> t list) {
  -> g;
  [] { g glue } fold-left
}

define last (∀ t . t list -> t option) { mlatu::last }

define last-init (∀ t . t list -> ((t list) t pair) option) {
  \last \init bi \mk-pair lift-option-2
}

define lefts (∀ a b . (b a either) list -> a list) { \get-left map-optionally }

define length (∀ t . t list -> int) { 0 { drop 1 (+) } fold-left }

define map (∀ a b . a list, (a -> b) -> b list) {
  -> f;
  match (hd-tl)
  case some { unpair -> h, t; (t f map) (h f call) cons }
  case none { [] }
}

define map2 (∀ a b c . a list, b list, (a, b -> c) -> c list) {
  -> f;
  combine (\unpair f compose) map
}

define map-concat (∀ a b . a list, (a -> b list) -> b list) { map concat }

define mapi (∀ a b . a list, (a, int -> b) -> b list) {
  0 mapi::helper
}

define map-optionally (∀ a b . a list, (a -> b option) -> b list) {
  -> f;
  match (hd-tl)
  case some {
    unpair -> h, t;
    match (h f call)
    case some -> x { (t f map-optionally) x cons }
    case none { t f map-optionally }
  }
  case none { [] }
}

define map-reduce-left (∀ a b . a list, (a -> b), (b, b -> b) -> b option) {
  -> f;
  map f reduce-left
}

define map-reduce-left2 (∀ a b c . a list, b list, (a, b -> c), (c, c -> c) -> c option) {
  -> f;
  map2 f reduce-left
}

define map-reduce-right (∀ a b . a list, (a -> b), (b, b -> b) -> b option) {
  -> f;
  map f reduce-right
}

define map-reduce-right2 (∀ a b c . a list, b list, (a, b -> c), (c, c -> c) -> c option) {
  -> f;
  map2 f reduce-right
}

define maximum (∀ t . t list -> t option) { \max reduce-left }

define minimum (∀ t . t list -> t option) { \min reduce-left }

define modify (∀ t . t list, (t -> t), int -> t list) {
  -> xs, f, i;
  match (xs i get)
  case some -> x { xs (x f call) i set }
  case none { xs }
}

define once (∀ t . t -> t list) { -> x; [x] }

define or (bool list -> bool) { true \(|) fold-left }

define pad-hd (∀ t . t list, int, t -> t list) {
  -> min-length, elt; dup
  if (length min-length <) {
    dup -> list; elt min-length list length - replicate prepend
  }
  else { }
}

define pad-tl (∀ t . t list, int, t -> t list) {
  -> min-length, elt; dup
  if (length min-length <) {
    -> list; elt min-length list length - replicate list prepend
  }
  else { }
}

define partition (∀ t . t list, (t -> bool) -> t list, t list) {
  -> l, f;
  l f filter l { f call not} filter
}

define partition-map (∀ a b . (b a either) list -> a list, b list) {
  -> xs;
  xs lefts xs rights
}

define cons (∀ t . t list, t -> t list) { once prepend }

define prepend (∀ t . t list, t list -> t list) { swap append }

define reduce-left (∀ t . t list, (t, t -> t) -> t option) {
  -> f;
  tl-hd { unpair f fold-left } map-option
}

define reduce-right (∀ t . t list, (t, t -> t) -> t option) {
  -> f;
  init-last { unpair f fold-right } map-option
}

define remove (∀ t . t list, t -> t list) { -> x; { x <> } filter }

define remove-nth (∀ t . t list, int -> t list) {
  -> index;
  { if (index =) { drop [] } else { -> x; [x] } } mapi concat
}

define replicate (∀ t . t, int -> t list) {
  -> count; if (count 0 <=) { drop [] }
  else { -> value; value count 1 - replicate value suffix }
}

define rev (∀ t . t list -> t list) {
  match (hd-tl)
  case some { unpair rev swap suffix }
  case none { [] }
}

define rights (∀ a b . (b a either) list -> b list) {
  \get-right map-optionally
}

define set (∀ t . t list, t, int -> t list) {
  -> element, index;
  { if (index =) { drop element } else {} } mapi
}

define suffix (∀ t . t list, t -> t list) { once append }

define surround (∀ t . t list, t list, t list -> t list) {
  -> x;
  prepend x append
}

define tl (∀ t . t list -> (t list) option) { mlatu::tl }

define tl-hd (∀ t . t list -> (t (t list) pair) option) {
  \tl \hd bi \mk-pair lift-option-2
}

define split (∀ a b . (b a pair) list -> a list, b list) {
  match (hd-tl)
  case some {
    unpair -> h, t;
    h unpair -> m, n;
    t split -> ms, ns;
    ms m cons ns n cons
  }
  case none { [] [] }
}

define combine (∀ a b . a list, b list -> (b a pair) list) {
  -> a, b;
  match (a hd-tl)
  case some -> x-pair {
    match (b hd-tl)
    case some -> y-pair {
      (x-pair second) (y-pair second) combine (x-pair first) (y-pair first) mk-pair cons
    }
    case none { [] }
  }
  case none { [] }
}

define mapi::helper (∀ a b . a list, (a, int -> b), int -> b list) {
  -> f, i;
  match (hd-tl)
  case some { unpair -> h, t; t f i 1 + helper h i f call cons }
  case none { [] }
}
