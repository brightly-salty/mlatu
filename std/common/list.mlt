vocab mlatu:
  intrinsic cat [T] (List[T], List[T] -> List[T])
  intrinsic empty [T] (List[T] -> Bool)
  intrinsic get [T] (List[T], Int -> Optional[T])
  intrinsic head [T] (List[T] -> Optional[T])
  intrinsic init [T] (List[T] -> Optional[List[T]])
  intrinsic last [T] (List[T] -> Optional[T])
  intrinsic set [T] (List[T], T, Int -> Optional[List[T]])
  intrinsic tail [T] (List[T] -> Optional[List[T]])

type List[T]:
  case _list (Pointer[T], Pointer[T], Pointer[T])


instance < (List[Int], List[Int] -> Bool):
  swap (>)

instance <= (List[Int], List[Int] -> Bool):
  (>) not

instance <> (List[Int], List[Int] -> Bool):
  (=) not

instance = (List[Int], List[Int] -> Bool):
  -> xs, ys;
  if (xs length ys <> length):
    false
  else:
    match (xs (head_tail))
    case some:
      unpair -> x, xs_;
             match (ys (head_tail))
             case some:
               unpair -> y, ys_;
                      if (x y <>):
                        false
                      else:
                        (xs_) (ys_) =
             case none:
               true
    case none:
      true

instance > (List[Int], List[Int] -> Bool):
  -> xs, ys;
  match (xs (head_tail))
  case some:
    unpair -> x, xs_;
           match (ys (head_tail))
           case some:
             unpair -> y, ys_;
                    if (x y >):
                      true
                    else:
                      if (x y <):
                        false
                      else:
                        (xs_) (ys_) >
           case none:
             true
  case none:
    false

instance >= (List[Int], List[Int] -> Bool):
  (<) not

define all[T] (List[T], (T -> Bool) -> Bool):
  -> f; true (fold_left) { f (&) call }

define and(List[Bool] -> Bool):
  true (fold_left) \(&)

define any[T] (List[T], (T -> Bool) -> Bool):
  -> f; true (fold_left) { f (|) call }

define append[T] (List[T], T -> List[T]):
  -> list, elem; list cat once elem

define cartesian[A, B] (List[A], List[B] -> List[Pair[A, B]]):
  \pair (cartesian_with)

define cartesian_with[A, B, C] (List[A], List[B], (A, B -> C) -> List[C]):
  -> ys, f; do ((map_concat)):
              -> x; ys (map) { -> y; x call f y }

define cat[T] (List[T], List[T] -> List[T]):
  _::mlatu::cat

define concat[T] (List[List[T]] -> List[T]):
  [] (fold_left) \cat

define concat_optionals[T] (List[Optional[T]] -> List[T]):
  [] (fold_left) {
                 match
                 case some:
                   append
                 else {} }

define each[T, +P] (List[T], (T -> +P) -> +P):
  -> f;
  match ((head_tail))
  case some:
    unpair -> h, t; h each f t call f
  case none {}

define elem[T] (T, List[T] -> Bool):
  -> x, xs;
  match (xs (head_tail))
  case some:
    unpair -> h, t;
           if (x h =):
             true
           else:
             x elem t
  case none:
    false

define empty[T] (List[T] -> Bool):
  _::mlatu::empty

define filter[T] (List[T], (T -> Bool) -> List[T]):
  -> f;
  match ((head_tail))
  case some:
    unpair -> h, t;
           if (h call f):
             h prepend (t filter f)
           else:
             t filter f
  case none:
    []

define find[T] (List[T], (T -> Bool) -> Optional[T]):
  filter head

define fold_left[A, B] (List[B], A, (A, B -> A) -> A):
  -> xs, z, k;
  match (xs head)
  case some:
    -> x; do (with (+Fail)):
            xs (from_some) "fold_left: tail should not be none if head is some" tail
    (fold_left) k (z call k x)
  case none:
    z

define fold_left_non_empty[T] (List[T], (T, T -> T) -> Optional[T]):
  -> xs, f;
  match (xs head)
  case some:
    -> x; do (with (+Fail)):
            xs (from_some) "fold_left_non_empty: tail should not be none if head is some" tail
    some (fold_left) f x
  else:
    none

define fold_right[A, B] (List[A], B, (A, B -> B) -> B):
  -> xs, z, k;
  match (xs last)
  case some:
    -> x; do (with (+Fail)):
            xs (from_some) "fold_right: init should not be none if last is some" init
    (fold_right) k (x call k z)
  else:
    z

define fold_right_non_empty[A] (List[A], (A, A -> A) -> Optional[A]):
  -> xs, f;
  match (xs last)
  case some:
    -> x; do (with (+Fail)):
            xs (from_some) "fold_right_non_empty: init should not be none if last is some" init
    some (fold_right) f x
  else:
    none

define get[T] (List[T], Int -> Optional[T]):
  _::mlatu::get

define get_all[T] (List[T], List[Int] -> List[Optional[T]]):
  -> list, indices; indices map { list get swap }

define head[T] (List[T] -> Optional[T]):
  _::mlatu::head

define head_tail[T] (List[T] -> Optional[Pair[T, List[T]]]):
  -> xs; none match
              case some:
                -> y;
                match (xs tail)
                case some:
                  -> ys; drop some pair ys y
                else {}
              else {} (xs head)

define init[T] (List[T] -> Optional[List[T]]):
  _::mlatu::init

define init_last[T] (List[T] -> Optional[Pair[List[T], T]]):
  -> xs; none match
              case some:
                -> ys;
                match (xs last)
                case some:
                  -> y; drop some pair y ys
                else {}
              else {} (xs init)

define last[T] (List[T] -> Optional[T]):
  _::mlatu::last

define length[T] (List[T] -> Int):
  match (tail)
  case none:
    0
  case some:
    length (+) 1


define map[A, B, +P] (List[A], (A -> B +P) -> List[B] +P):
  -> xs, f;
  match (xs (head_tail))
  case none:
    []
  case some:
    unpair -> y, ys; y -> z; ys -> zs; z prepend zs map f call f

define map_concat[A, B] (List[A], (A -> List[B]) -> List[B]):
  map concat

define map_index[A, B, +P] (List[A], (A, Int -> B +P) -> List[B] +P):
  0 map_index::helper

define maximum[T] (List[T] -> Optional[T]):
  \max (fold_left_non_empty)

define minimum[T] (List[T] -> Optional[T]):
  \min (fold_left_non_empty)

define modify[T] (List[T], (T -> T), Int -> Optional[List[T]]):
  -> xs, f, i;
  match (xs get i)
  case none:
    none
  case some:
    -> x; xs set i (x call f)

define not_elem[T] (T, List[T] -> Bool):
  -> x, xs;
  match (xs (head_tail))
  case some:
    unpair -> h, t;
           if (x h =):
             false
           else:
             x (not_elem) t
  case none:
    true

define once[T] (T -> List[T]):
  -> x; {x}

define or(List[Bool] -> Bool):
  true (fold_left) \(|)

define prepend[T] (T, List[T] -> List[T]):
  -> elem, list; elem cat list once

define replicate[T] (T, Int -> List[T]):
  -> value, count;
  if (count 0 <=):
    []
  else:
    value append value replicate (count 1 -)

define reverse[T] (List[T] -> List[T]):
  -> xs;
  match (xs (head_tail))
  case some:
    unpair -> h, t; t append h reverse
  case none:
    []

define set[T] (List[T], T, Int -> Optional[List[T]]):
  _::mlatu::set

define tail[T] (List[T] -> Optional[List[T]]):
  _::mlatu::tail

define unzip[A, B] (List[Pair[A, B]] -> List[A], List[B]):
  match ((head_tail))
  case some:
    unpair -> x, xs; x -> m, n; xs -> ms, ns; m prepend ns n prepend ms unzip unpair
  case none:
    [] []

define zip[A, B] (List[A], List[B] -> List[Pair[A, B]]):
  -> a, b;
  match (a (head_tail))
  case some:
    unpair -> x, xs;
           match (b (head_tail))
           case some:
             unpair -> y, ys; x -> z; xs -> zs; z prepend zs zip ys pair y
           case none:
             []
  case none:
    []

define _::map_index::helper[A, B, +P] (List[A], (A, Int -> B +P), Int -> List[B] +P):
  -> xs, f, i;
  match (xs (head_tail))
  case none:
    []
  case some:
    unpair -> y, ys; y -> z; ys -> zs; z prepend zs helper (i 1 +) f call f i