vocab mlatu {
  intrinsic cat (forall T . List T, List T -> List T)
  intrinsic empty (forall T . List T -> Bool)
  intrinsic get (forall T . List T, Int -> Optional T)
  intrinsic head (forall T . List T -> Optional T)
  intrinsic init (forall T . List T -> Optional List T)
  intrinsic last (forall T . List T -> Optional T)
  intrinsic set (forall T . List T, T, Int -> Optional List T)
  intrinsic tail (forall T .  List T -> Optional List T)
}

type List T {}

/*
instance Lt for List[Int] { define < (List[Int], List[Int] -> Bool) { swap (>) } }

instance Le for List[Int] { define <= (List[Int], List[Int] -> Bool) { (>) not } }

instance Ne for List[Int] { define <> (List[Int], List[Int] -> Bool) { (=) not } }

instance Eq for List[Int] { define = (List[Int], List[Int] -> Bool) {
  -> xs, ys;
  if (xs length ys length <>) { false }
  else {
    match (xs head_tail)
    case some {
      unpair -> x, xs_;
      match (ys head_tail)
      case some { unpair -> y, ys_; if (x y <>) { false } else { xs_ ys_ =} }
      case none { true }
    }
    case none { true }
  }
} }

instance Gt for List[Int] { define > (List[Int], List[Int] -> Bool) {
  -> xs, ys;
  match (xs head_tail)
  case some {
    unpair -> x, xs_;
    match (ys head_tail)
    case some {
      unpair -> y, ys_;
      if (x y >) { true }
      else { if (x y <) { false } else { xs_ ys_ >} }
    }
    case none { true }
  }
  case none { false }
} }

instance Ge for List[Int] { define >= (List[Int], List[Int] -> Bool) { (<) not } }
*/

define all (forall T . List T, (T -> Bool) -> Bool) {
  -> f;
  true do (fold_left) { f call (&) }
}

define all2 (forall A B . List A, List B, (A, B -> Bool) -> Bool) {
  -> f;
  zip { unpair f call } all
}

define and (List Bool -> Bool) { true \(&) fold_left }

define any (forall T . List T, (T -> Bool) -> Bool) {
  -> f;
  true do (fold_left) { f call (|) }
}

define any2 (forall A B . List A, List B, (A, B -> Bool) -> Bool) {
  -> f;
  zip { unpair f call } any
}

define append (forall T . List T, List T -> List T) { _::mlatu::cat }

define append3 (forall T . List T, List T, List T -> List T) { append append }

define cartesian (forall A B . List A, List B -> List Pair A B) {
  \pair cartesian_with
}

define cartesian_with (forall A B C . List A, List B, (A, B -> C) -> List C) {
  -> ys, f;
  { -> x; ys { x swap f call } map } map_concat
}

define concat (forall T . List List T -> List T) { [] \append fold_left }

define concat_optionals (forall T . List Optional T -> List T) {
  [] { match case some { suffix } else {} } fold_left
}

define each (forall T . List T, (T ->) ->) {
  -> f;
  match (head_tail)
  case some { unpair -> h, t; h f call t f each }
  case none {}
}

define each2 (forall A B . List A, List B, (A, B ->) ->) {
  -> f;
  zip { unpair f call } each
}

define elem (forall T . T, List T -> Bool) { swap -> x; { x (=) } any }

define empty (forall T . List T -> Bool) { _::mlatu::empty }

define filter_in (forall T . List T, (T -> Bool) -> List T) {
  -> f;
  match (tail_head)
  case some { unpair -> t, h; t f filter_in (h f call) if { h prefix } else {} }
  case none { [] }
}

define filter_out (forall T . List T, (T -> Bool) -> List T) {
  -> f;
  { f call not } filter_in
}

define find (forall T . List T, (T -> Bool) -> Optional T) { filter_in head }

define fold_left (forall A B . List B, A, (A, B -> A) -> A) {
  -> xs, z, k;
  match (xs tail_head)
  case some { unpair -> h; (z h k call) k fold_left }
  case none { z }
}

define fold_right (forall A B . List A, B, (A, B -> B) -> B) {
  -> xs, z, k;
  match (xs init_last)
  case some { unpair z k call k fold_right }
  case none { z }
}

define get (forall T . List T, Int -> Optional T) { _::mlatu::get }

define get_all (forall T . List T, List Int -> List Optional T) {
  swap -> list;
  { list swap get } map
}

define glue (forall T . List T, List T, List T -> List T) { prepend append }

define head (forall T . List T -> Optional T) { _::mlatu::head }

define head_tail (forall T . List T -> Optional Pair T List T) {
  \head \tail bi \pair lift_optional_2
}

define init (forall T . List T -> Optional List T) { _::mlatu::init }

define init_last (forall T . List T -> Optional Pair (List T) T) {
  \init \last bi \pair lift_optional_2
}

define insert_nth (forall T . List T, T, Int -> List T) {
  -> element, index;
  { -> x, i; if (i index =) { [element, x] } else { [x] } } map_index concat
}

define join (forall T . List List T, List T -> List T) {
  -> g;
  [] { g glue } fold_left
}

define last (forall T . List T -> Optional T) { _::mlatu::last }

define last_init (forall T . List T -> Optional Pair T List T) {
  \last \init bi \pair lift_optional_2
}

define lefts (forall A B . List Either A B -> List A) { \get_left map_optionally }

define length (forall T . List T -> Int) { 0 { drop 1 (+) } fold_left }

define map (forall A B . List A, (A -> B) -> List B) {
  -> f;
  match (head_tail)
  case some { unpair -> h, t; (t f map) (h f call) prefix }
  case none { [] }
}

define map2 (forall A B C . List A, List B, (A, B -> C) -> List C) {
  -> f;
  zip (\unpair f compose) map
}

define map_concat (forall A B . List A, (A -> List B) -> List B) { map concat }

define map_index (forall A B . List A, (A, Int -> B) -> List B) {
  0 map_index::helper
}

define map_optionally (forall A B . List A, (A -> Optional B) -> List B) {
  -> f;
  match (head_tail)
  case some {
    unpair -> h, t;
    match (h f call)
    case some -> x { (t f map_optionally) x prefix }
    case none { t f map_optionally }
  }
  case none { [] }
}

define map_reduce_left (forall A B . List A, (A -> B), (B, B -> B) -> Optional B) {
  -> f;
  map f reduce_left
}

define map_reduce_left2 (forall A B C . List A, List B, (A, B -> C), (C, C -> C) -> Optional C) {
  -> f;
  map2 f reduce_left
}

define map_reduce_right (forall A B . List A, (A -> B), (B, B -> B) -> Optional B) {
  -> f;
  map f reduce_right
}

define map_reduce_right2 (forall A B C . List A, List B, (A, B -> C), (C, C -> C) -> Optional C) {
  -> f;
  map2 f reduce_right
}

define maximum (forall T . List T -> Optional T) { \max reduce_left }

define minimum (forall T . List T -> Optional T) { \min reduce_left }

define modify (forall T . List T, (T -> T), Int -> List T) {
  -> xs, f, i;
  match (xs i get)
  case some -> x { xs (x f call) i set }
  case none { xs }
}

define not_elem (forall T . T, List T -> Bool) { elem not }

define once (forall T . T -> List T ) { -> x; [x] }

define or (List Bool -> Bool) { true \(|) fold_left }

define pad_head (forall T . List T, Int, T -> List T) {
  -> list, min_length, elt;
  if (list length min_length <) {
    list (elt (min_length list length -) replicate) prepend
  }
  else { list }
}

define pad_tail (forall T . List T, Int, T -> List T) {
  -> list, min_length, elt;
  if (list length min_length <) {
    (elt (min_length list length -) replicate) list prepend
  }
  else { list }
}

define partition (forall T . List T, (T -> Bool) -> List T, List T) {
  -> f;
  { f filter_in } { f filter_out } bi
}

define partition_eithers (forall A B . List Either A B -> List A, List B) {
  -> xs;
  (xs lefts) (xs rights)
}

define prefix (forall T . List T, T -> List T) { once prepend }

define prepend (forall T . List T, List T -> List T) { swap append }

define reduce_left (forall T . List T, (T, T -> T) -> Optional T) {
  -> f;
  tail_head { unpair f fold_left } map_optional
}

define reduce_right (forall T . List T, (T, T -> T) -> Optional T) {
  -> f;
  init_last { unpair f fold_right } map_optional
}

define remove (forall T . List T, T -> List T) { -> x; { x = } filter_out }

define remove_nth (forall T . List T, Int -> List T) {
  -> index;
  { -> x, i; if (i index =) { [] } else { [x] } } map_index concat
}

define replicate (forall T . T, Int -> List T) {
  -> value, count;
  if (count 0 <=) { [] }
  else { value (count 1 -) replicate value suffix }
}

define reverse (forall T . List T -> List T) {
  match (head_tail)
  case some { unpair reverse swap suffix }
  case none { [] }
}

define rights (forall A B . List Either A B -> List B) {
  \get_right map_optionally
}

define set (forall T . List T, T, Int -> List T) {
  -> element, index;
  do  (map_index) { -> i; if (i index =) { drop element } else {} }
}

define suffix (forall T . List T, T -> List T ) { once append }

define surround (forall T . List T, List T, List T  -> List T) {
  -> x;
  prepend x append
}

define tail (forall T . List T -> Optional List T) { _::mlatu::tail }

define tail_head (forall T . List T  -> Optional Pair (List T) T) {
  \tail \head bi \pair lift_optional_2
}

define unzip (forall A B . List Pair A B -> List A, List B) {
  match (head_tail)
  case some {
    unpair -> h, t;
    h unpair -> m, n;
    t unzip -> ms, ns;
    ms m prefix ns n prefix
  }
  case none { [] [] }
}

define zip (forall A B . List A, List B -> List Pair A B) {
  -> a, b;
  match (a head_tail)
  case some -> x_pair {
    match (b head_tail)
    case some -> y_pair {
      (x_pair second) (y_pair second) zip (x_pair first) (y_pair first) pair prefix
    }
    case none { [] }
  }
  case none { [] }
}

define _::map_index::helper (forall A B . List A, (A, Int -> B), Int -> List B) {
  -> f, i;
  match (head_tail)
  case some { unpair -> h, t; (t f (i 1 +) helper) (h i f call) prefix }
  case none { [] }
}
