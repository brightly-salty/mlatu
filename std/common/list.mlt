vocab mlatu {
  intrinsic cat (∀ t . t list, t list -> t list)
  intrinsic empty (∀ t . t list -> bool)
  intrinsic get (∀ t . t list, int -> t optional)
  intrinsic head (∀ t . t list -> t optional)
  intrinsic init (∀ t . t list -> (t list) optional)
  intrinsic last (∀ t . t list -> t optional)
  intrinsic set (∀ t . t list, t, int -> (t list) optional)
  intrinsic tail (∀ t . t list -> (t list) optional)
}

type list[t] {}

define all (∀ t . t list, (t -> bool) -> bool) {
  -> f;
  true do (fold-left) { f call (&) }
}

define all2 (∀ a b . a list, b list, (a, b -> bool) -> bool) {
  -> f;
  zip { unpair f call } all
}

define and (bool list -> bool) { true \(&) fold-left }

define any (∀ t . t list, (t -> bool) -> bool) {
  -> f;
  true do (fold-left) { f call (|) }
}

define any2 (∀ a b . a list, b list, (a, b -> bool) -> bool) {
  -> f;
  zip { unpair f call } any
}

define append (∀ t . t list, t list -> t list) { mlatu::cat }

define append3 (∀ t . t list, t list, t list -> t list) { append append }

define cartesian (∀ a b . a list, b list -> (b a pair) list) {
  \mk-pair cartesian-with
}

define cartesian-with (∀ a b c . a list, b list, (a, b -> c) -> c list) {
  -> ys, f;
  { -> x; ys { x swap f call } map } map-concat
}

define concat (∀ t . (t list) list -> t list) { [] \append fold-left }

define concat-optionals (∀ t . (t optional) list -> t list) {
  [] do (fold-left) { match case some { suffix } else {} }
}

define each (∀ t . t list, (t ->) ->) {
  -> f;
  match (head-tail)
  case some { unpair -> h, t; h f call t f each }
  case none {}
}

define each2 (∀ a b . a list, b list, (a, b ->) ->) {
  -> f;
  zip { unpair f call } each
}

define elem (∀ t . t, t list -> bool) { swap -> x; { x (=) } any }

define empty (∀ t . t list -> bool) { mlatu::empty }

define filter-in (∀ t . t list, (t -> bool) -> t list) {
  -> f;
  match (tail-head)
  case some { unpair -> t, h; t f filter-in (h f call) if { h prefix } else {} }
  case none { [] }
}

define filter-out (∀ t . t list, (t -> bool) -> t list) {
  -> f;
  { f call not } filter-in
}

define find (∀ t . t list, (t -> bool) -> t optional) { filter-in head }

define fold-left (∀ a b . b list, a, (a, b -> a) -> a) {
  -> xs, z, k;
  match (xs tail-head)
  case some { unpair -> h; (z h k call) k fold-left }
  case none { z }
}

define fold-right (∀ a b . a list, b, (a, b -> b) -> b) {
  -> xs, z, k;
  match (xs init-last)
  case some { unpair z k call k fold-right }
  case none { z }
}

define get (∀ t . t list, int -> t optional) { mlatu::get }

define get-all (∀ t . t list, int list -> (t optional) list) {
  swap -> list;
  { list swap get } map
}

define glue (∀ t . t list, t list, t list -> t list) { prepend append }

define head (∀ t . t list -> t optional) { mlatu::head }

define head-tail (∀ t . t list -> ((t list) t pair) optional) {
  \head \tail bi \mk-pair lift-optional-2
}

define init (∀ t . t list -> (t list) optional) { mlatu::init }

define init-last (∀ t . t list -> (t (t list) pair) optional) {
  \init \last bi \mk-pair lift-optional-2
}

define insert-nth (∀ t . t list, t, int -> t list) {
  -> element, index;
  { if (index =) { -> x; [element, x] } else { -> x; [x] } } map-index concat
}

define join (∀ t . (t list) list, t list -> t list) {
  -> g;
  [] { g glue } fold-left
}

define last (∀ t . t list -> t optional) { mlatu::last }

define last-init (∀ t . t list -> ((t list) t pair) optional) {
  \last \init bi \mk-pair lift-optional-2
}

define lefts (∀ a b . (b a either) list -> a list) { \get-left map-optionally }

define length (∀ t . t list -> int) { 0 { drop 1 (+) } fold-left }

define map (∀ a b . a list, (a -> b) -> b list) {
  -> f;
  match (head-tail)
  case some { unpair -> h, t; (t f map) (h f call) prefix }
  case none { [] }
}

define map2 (∀ a b c . a list, b list, (a, b -> c) -> c list) {
  -> f;
  zip (\unpair f compose) map
}

define map-concat (∀ a b . a list, (a -> b list) -> b list) { map concat }

define map-index (∀ a b . a list, (a, int -> b) -> b list) {
  0 map-index::helper
}

define map-optionally (∀ a b . a list, (a -> b optional) -> b list) {
  -> f;
  match (head-tail)
  case some {
    unpair -> h, t;
    match (h f call)
    case some -> x { (t f map-optionally) x prefix }
    case none { t f map-optionally }
  }
  case none { [] }
}

define map-reduce-left (∀ a b . a list, (a -> b), (b, b -> b) -> b optional) {
  -> f;
  map f reduce-left
}

define map-reduce-left2 (∀ a b c . a list, b list, (a, b -> c), (c, c -> c) -> c optional) {
  -> f;
  map2 f reduce-left
}

define map-reduce-right (∀ a b . a list, (a -> b), (b, b -> b) -> b optional) {
  -> f;
  map f reduce-right
}

define map-reduce-right2 (∀ a b c . a list, b list, (a, b -> c), (c, c -> c) -> c optional) {
  -> f;
  map2 f reduce-right
}

define maximum (∀ t . t list -> t optional) { \max reduce-left }

define minimum (∀ t . t list -> t optional) { \min reduce-left }

define modify (∀ t . t list, (t -> t), int -> t list) {
  -> xs, f, i;
  match (xs i get)
  case some -> x { xs (x f call) i set }
  case none { xs }
}

define not-elem (∀ t . t, t list -> bool) { elem not }

define once (∀ t . t -> t list) { -> x; [x] }

define or (bool list -> bool) { true \(|) fold-left }

define pad-head (∀ t . t list, int, t -> t list) {
  -> min-length, elt; dup
  if (length min-length <) {
    dup -> list; elt min-length list length - replicate prepend
  }
  else { }
}

define pad-tail (∀ t . t list, int, t -> t list) {
  -> min-length, elt; dup
  if (length min-length <) {
    -> list; elt min-length list length - replicate list prepend
  }
  else { }
}

define partition (∀ t . t list, (t -> bool) -> t list, t list) {
  -> f;
  { f filter-in } { f filter-out } bi
}

define partition-eithers (∀ a b . (b a either) list -> a list, b list) {
  -> xs;
  xs lefts xs rights
}

define prefix (∀ t . t list, t -> t list) { once prepend }

define prepend (∀ t . t list, t list -> t list) { swap append }

define reduce-left (∀ t . t list, (t, t -> t) -> t optional) {
  -> f;
  tail-head { unpair f fold-left } map-optional
}

define reduce-right (∀ t . t list, (t, t -> t) -> t optional) {
  -> f;
  init-last { unpair f fold-right } map-optional
}

define remove (∀ t . t list, t -> t list) { -> x; { x (=) } filter-out }

define remove-nth (∀ t . t list, int -> t list) {
  -> index;
  { if (index =) { drop [] } else { -> x; [x] } } map-index concat
}

define replicate (∀ t . t, int -> t list) {
  -> count; if (count 0 <=) { drop [] }
  else { -> value; value count 1 - replicate value suffix }
}

define reverse (∀ t . t list -> t list) {
  match (head-tail)
  case some { unpair reverse swap suffix }
  case none { [] }
}

define rights (∀ a b . (b a either) list -> b list) {
  \get-right map-optionally
}

define set (∀ t . t list, t, int -> t list) {
  -> element, index;
  { if (index =) { drop element } else {} } map-index
}

define suffix (∀ t . t list, t -> t list) { once append }

define surround (∀ t . t list, t list, t list -> t list) {
  -> x;
  prepend x append
}

define tail (∀ t . t list -> (t list) optional) { mlatu::tail }

define tail-head (∀ t . t list -> (t (t list) pair) optional) {
  \tail \head bi \mk-pair lift-optional-2
}

define unzip (∀ a b . (b a pair) list -> a list, b list) {
  match (head-tail)
  case some {
    unpair -> h, t;
    h unpair -> m, n;
    t unzip -> ms, ns;
    ms m prefix ns n prefix
  }
  case none { [] [] }
}

define zip (∀ a b . a list, b list -> (b a pair) list) {
  -> a, b;
  match (a head-tail)
  case some -> x-pair {
    match (b head-tail)
    case some -> y-pair {
      (x-pair second) (y-pair second) zip (x-pair first) (y-pair first) mk-pair prefix
    }
    case none { [] }
  }
  case none { [] }
}

define map-index::helper (∀ a b . a list, (a, int -> b), int -> b list) {
  -> f, i;
  match (head-tail)
  case some { unpair -> h, t; t f i 1 + helper h i f call prefix }
  case none { [] }
}
